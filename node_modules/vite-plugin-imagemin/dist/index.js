"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// src/index.ts
var _path = require('path'); var _path2 = _interopRequireDefault(_path);
var _vite = require('vite');

// src/utils.ts
var _fs = require('fs'); var _fs2 = _interopRequireDefault(_fs);

var isFunction = (arg) => typeof arg === "function";
var isBoolean = (arg) => {
  return typeof arg === "boolean";
};
var isNotFalse = (arg) => {
  return !(isBoolean(arg) && !arg);
};
var isRegExp = (arg) => Object.prototype.toString.call(arg) === "[object RegExp]";
function readAllFile(root, reg) {
  let resultArr = [];
  try {
    if (_fs2.default.existsSync(root)) {
      const stat = _fs2.default.lstatSync(root);
      if (stat.isDirectory()) {
        const files = _fs2.default.readdirSync(root);
        files.forEach(function(file) {
          const t = readAllFile(_path2.default.join(root, "/", file), reg);
          resultArr = resultArr.concat(t);
        });
      } else {
        if (reg !== void 0) {
          if (isFunction(reg.test) && reg.test(root)) {
            resultArr.push(root);
          }
        } else {
          resultArr.push(root);
        }
      }
    }
  } catch (error) {
  }
  return resultArr;
}

// src/index.ts
var _fsextra = require('fs-extra'); var _fsextra2 = _interopRequireDefault(_fsextra);
var _chalk = require('chalk'); var _chalk2 = _interopRequireDefault(_chalk);
var _debug = require('debug');
var _imagemin = require('imagemin'); var _imagemin2 = _interopRequireDefault(_imagemin);
var _imagemingifsicle = require('imagemin-gifsicle'); var _imagemingifsicle2 = _interopRequireDefault(_imagemingifsicle);
var _imageminpngquant = require('imagemin-pngquant'); var _imageminpngquant2 = _interopRequireDefault(_imageminpngquant);
var _imageminoptipng = require('imagemin-optipng'); var _imageminoptipng2 = _interopRequireDefault(_imageminoptipng);
var _imageminmozjpeg = require('imagemin-mozjpeg'); var _imageminmozjpeg2 = _interopRequireDefault(_imageminmozjpeg);
var _imageminsvgo = require('imagemin-svgo'); var _imageminsvgo2 = _interopRequireDefault(_imageminsvgo);
var _imageminwebp = require('imagemin-webp'); var _imageminwebp2 = _interopRequireDefault(_imageminwebp);
var _imageminjpegtran = require('imagemin-jpegtran'); var _imageminjpegtran2 = _interopRequireDefault(_imageminjpegtran);
var debug = _debug.debug.call(void 0, "vite-plugin-imagemin");
var extRE = /\.(png|jpeg|gif|jpg|bmp|svg)$/i;
var mtimeCache = new Map();
var exportFn = (options = {}) => {
  let outputPath;
  let config;
  const emptyPlugin = {
    name: "vite:imagemin"
  };
  const { disable = false, filter = extRE, verbose = true } = options;
  if (disable) {
    return emptyPlugin;
  }
  debug("plugin options:", options);
  return __spreadProps(__spreadValues({}, emptyPlugin), {
    apply: "build",
    enforce: "post",
    configResolved(resolvedConfig) {
      config = resolvedConfig;
      outputPath = _path2.default.join(config.root, config.build.outDir);
      debug("resolvedConfig:", resolvedConfig);
    },
    async closeBundle() {
      let files = readAllFile(outputPath) || [];
      debug("files:", files);
      if (!files.length) {
        return;
      }
      files = filterFiles(files, filter);
      const tinyMap = new Map();
      const handles = files.map(async (filePath) => {
        let { mtimeMs, size: oldSize } = await _fsextra2.default.stat(filePath);
        if (mtimeMs <= (mtimeCache.get(filePath) || 0)) {
          return;
        }
        let content = await _fsextra2.default.readFile(filePath);
        try {
          content = await _imagemin2.default.buffer(content, {
            plugins: getImageminPlugins(options)
          });
        } catch (error) {
          config.logger.error("imagemin error:" + filePath);
        }
        const size = content.byteLength;
        tinyMap.set(filePath, {
          size: size / 1024,
          oldSize: oldSize / 1024,
          ratio: size / oldSize - 1
        });
        await _fsextra2.default.writeFile(filePath, content);
        mtimeCache.set(filePath, Date.now());
      });
      Promise.all(handles).then(() => {
        if (verbose) {
          handleOutputLogger(config, tinyMap);
        }
      });
    }
  });
};
function handleOutputLogger(config, recordMap) {
  config.logger.info(`
${_chalk2.default.cyan("\u2728 [vite-plugin-imagemin]")}- compressed image resource successfully: `);
  const keyLengths = Array.from(recordMap.keys(), (name) => name.length);
  const valueLengths = Array.from(recordMap.values(), (value) => `${Math.floor(100 * value.ratio)}`.length);
  const maxKeyLength = Math.max(...keyLengths);
  const valueKeyLength = Math.max(...valueLengths);
  recordMap.forEach((value, name) => {
    let { ratio, size, oldSize } = value;
    const rName = _vite.normalizePath.call(void 0, name).replace(_vite.normalizePath.call(void 0, `${config.root}/${config.build.outDir}/`), "");
    ratio = Math.floor(100 * ratio);
    const fr = `${ratio}`;
    const denseRatio = ratio > 0 ? _chalk2.default.red(`+${fr}%`) : ratio <= 0 ? _chalk2.default.green(`${fr}%`) : "";
    const sizeStr = `${oldSize.toFixed(2)}kb / tiny: ${size.toFixed(2)}kb`;
    config.logger.info(_chalk2.default.dim(config.build.outDir + "/") + _chalk2.default.blueBright(rName) + " ".repeat(2 + maxKeyLength - name.length) + _chalk2.default.gray(`${denseRatio} ${" ".repeat(valueKeyLength - fr.length)}`) + " " + _chalk2.default.dim(sizeStr));
  });
  config.logger.info("\n");
}
function filterFiles(files, filter) {
  if (filter) {
    const isRe = isRegExp(filter);
    const isFn = isFunction(filter);
    files = files.filter((file) => {
      if (isRe) {
        return filter.test(file);
      }
      if (isFn) {
        return filter(file);
      }
      return true;
    });
  }
  return files;
}
function getImageminPlugins(options = {}) {
  const {
    gifsicle = true,
    webp = false,
    mozjpeg = false,
    pngquant = false,
    optipng = true,
    svgo = true,
    jpegTran = true
  } = options;
  const plugins = [];
  if (isNotFalse(gifsicle)) {
    debug("gifsicle:", true);
    const opt = isBoolean(gifsicle) ? void 0 : gifsicle;
    plugins.push(_imagemingifsicle2.default.call(void 0, opt));
  }
  if (isNotFalse(mozjpeg)) {
    debug("mozjpeg:", true);
    const opt = isBoolean(mozjpeg) ? void 0 : mozjpeg;
    plugins.push(_imageminmozjpeg2.default.call(void 0, opt));
  }
  if (isNotFalse(pngquant)) {
    debug("pngquant:", true);
    const opt = isBoolean(pngquant) ? void 0 : pngquant;
    plugins.push(_imageminpngquant2.default.call(void 0, opt));
  }
  if (isNotFalse(optipng)) {
    debug("optipng:", true);
    const opt = isBoolean(optipng) ? void 0 : optipng;
    plugins.push(_imageminoptipng2.default.call(void 0, opt));
  }
  if (isNotFalse(svgo)) {
    debug("svgo:", true);
    const opt = isBoolean(svgo) ? void 0 : svgo;
    plugins.push(_imageminsvgo2.default.call(void 0, opt));
  }
  if (isNotFalse(webp)) {
    debug("webp:", true);
    const opt = isBoolean(webp) ? void 0 : webp;
    plugins.push(_imageminwebp2.default.call(void 0, opt));
  }
  if (isNotFalse(jpegTran)) {
    debug("webp:", true);
    const opt = isBoolean(jpegTran) ? void 0 : jpegTran;
    plugins.push(_imageminjpegtran2.default.call(void 0, opt));
  }
  return plugins;
}
var src_default = exportFn;
module.exports = exportFn;


exports.default = src_default;
